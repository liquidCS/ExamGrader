{
  "1": {
    "text": "Suppose you are asked to implement the n-th Fibanacci number using\nrecursion only (i.e., no loop implementation)? How to avoid stack overflow for large\nn?\n使用遞迴實現第n個費波那契數,可定義一個遞迴函數,該函數返回第n個費\n波那契數。遞迴過程中,每次調用函數時,我們會對第n-1和n-2個費波那契\n數再次調用同一函數。但是,對於大的數n,使用純遞迴的方式容易導致溢出\n問題,因為每一次函數調用都會佔用堆疊空間。\n為了避免這個問題,可以採用記憶化遞迴(Memoization)的方法。具體來說,\n可以使用一個數組或哈希表來保存之前計算過的費波那契數值,當需要計算某\n個費波那契數時,首先查找是否已經計算過,如果已經計算過,直接返回結果,\n否則進行遞迴計算。這樣可以避免重複計算,同時減少遞迴深度,從而降低堆\n疊空間的使用量。\n下面是使用記憶化遞迴的C實作:\n#include <stdio.h>\n#define MAX 100\nint memory[MAX];\nint fibonacci(int n) {\nif (n <= 1) {\nreturn n;\n}\n}\nif (memo[n] != -1) {\nreturn memory[n];\n}\nreturn memory[n] = fibonacci(n - 1) + fibonacci(n - 2);\nint main() {\nint n = 50; // 要計算的費波那契數的索引\nfor (int i = 0; i < MAX; i++) {\n}\nmemory[i] = -1;\nprintf(\"第%d個費波那契數為%d\\n\", n, fibonacci(n));\nreturn 0;",
    "tables": [],
    "figures": []
  },
  "2": {
    "text": "What is the Big O complexity of following recurrence? Justify your answer.",
    "tables": [],
    "figures": []
  },
  "2a": {
    "text": "T(n) = 2T(n / 4) + T((2/3)n) + cn, where c is a constant.",
    "tables": [],
    "figures": []
  },
  "2b": {
    "text": "T(n) = 2T(√n)+lgn. (hint: you may replace n with other form)\n(a)\n這個遞迴式的Big O複雜度是O(nlogn)。\n可以使用主定理 (Master Theorem) 來證明這一點。\n遞迴式的形式為T(n) = 2T(n/4) + T((2/3)n) + cn\n根據主定理,如果存在常數k>0和d>=0,使得:\n\n對於所有的n大於某一個n0,有T(n)<=knd,那麼T(n)的複雜度是O(nd)。\n如果T(n) <= knd對於某一個常數d>0以及一些正數ɛ>0成立,同時對於充分\n大的n,有T(n) >= knd,那麼T(n) 的複雜度是O(nd * log n)。\n\n對於遞迴T(n) = 2T(n/4) + T((2/3)n)+cn,可以看到第二項T((2/3)n)的規模比較\n大,所以可以忽略掉其他項。因此,將遞迴式簡化為T(n) = T((2/3)n) + cn。這\n個遞迴式符合主定理的第二種情況,其中d=1,因此複雜度為O(nd * log n) =\nO(n * log n)。\n將n替換為2^k,其中k = log2(n),這樣可以將遞迴式表示為 T(2^k) = 2T(2^(k/2)) + k。\n這就變成了形式類似合併排序的遞迴式。因此,我們可以使用主定理來解這個\n遞迴式。\n\n根據主定理,如果遞迴式具有形式 T(n) = aT(n/b) + f(n),其中a>=1,b>1,且\nf(n) 是漸進正的,那麼:\n\n如果f(n) = O(n^(logb(a-ε))),對於某個ε>0,那麼T(n) = O(n^(logb(a)))。\n如果f(n) = Θ(n^(logb(a))),那麼T(n) = O(n^(logb(a)) * log n)。\n如果f(n) = Ω(n^(logb(a+ε))),對於某個ɛ>0,且af(n/b) <= cf(n) 對於某個c<1和所\n有足夠大的n,那麼T(n) = Θ(f(n))。\n\n對於遞迴式 T(2^k) = 2T(2^(k/2)) + k, a = 2, b = 2, f(n) = k。因為k = log2(n),所以f(n)",
    "tables": [],
    "figures": []
  },
  "3": {
    "text": "Prove that an n-element heap has at most n/(2(h+1)) nodes at height h.\n使用數學歸納法來證明這一點。\n基礎情況:當h=0時,這意味著在堆的最底層,即葉子節點所在的層級。在這種情況下,所有的葉子節點都是在同一個層級,每個葉子節點都是一個高度為0的節點。一個n元素的堆有n個葉子節點,因此在高度h=0的情況下,有n/(2(0+1)) = n/2 個節點。這是基礎情況。\n假設對於某個正整數k,當h=k時,一個n元素的堆最多有n/(2(k+1)) 個節點。\n接下來,假設高度為k+1的節點數量是 n/(2(k+2))。可以通過觀察堆的結構來進行證明。在高度為k+1的層級上,每個節點都有兩個子節點,這意味著在高度為k的層級上,每個節點都有2個父節點。\n因此,在高度為k的層級上,每個節點都負責其下層的兩倍節點的數量。由於假設高度為k的層級上有n/(2(k+1))個節點,所以高度為k+1的層級上的每個節點都負責其下層的n/(2(k+1)) *2 = n/(2(k+2)) 個節點的數量。\n因此,通過數學歸納法,證明了對於所有的正整數h,一個n元素的堆最多有n/(2(h+1)) 個節點。",
    "tables": [],
    "figures": []
  },
  "4": {
    "text": "Mr. Stupid claims we can sort n real numbers in linear time by multiplying a large integer to each real number such that all of them become integers. Then, the counting sort can be used to sort these integers in linear time. What is the problem of this method?\n將每個實數都乘以一個大整數以轉換成整數的方法可能會導致數據溢出。如果原始的實數數值非常大,將其乘以一個大整數後,可能會超出表示範圍,進而導致溢出錯誤。\n其次,即使假設數據不會溢出,將每個實數轉換成整數也可能會導致精度有問題。因為將實數轉換為整數會截斷小數部分,這樣可能會導致排序結果不準確。\n最後,即使忽略溢出和精度丟失的問題,使用計數排序來排序這些大整數也不一定會在線性時間內完成。計數排序通常用於整數排序,當整數的範圍很小且比較集中時才能夠達到線性時間的排序。但是在這種情況下,由於我們將實數轉換為整數後,整數的範圍可能會變得非常大,使得計數排序的效率大大降低。",
    "tables": [],
    "figures": []
  },
  "5": {
    "text": "綜上所述,這種方法存在著數據溢出、精度丟失以及計數排序效率不高的問題,\n因此並不適用於在線性時間內對實數進行排序。\n5. Longest common subsequence.\n(a) (10%) Write the optimal substructure (recurrence) of computing LCS of k\nsequences, where k = 3.\nWhat is the time complexity of computing LCS for k sequences of length n.\n(b) Mr. Smart claimed that the LCS of three sequences can be obtained by first\ncomputing LCSs of any two sequences (say LCS12), and then compute LCS of\nLCS12 and the remaining sequence. What's the bug of this method? Give an example.\n(c) Given a string, find the longest subsequence occurring at least twice in the string,\nrequiring their indices must not overlap. e.g., Given ATACTCGAG, the answer is 4\nsince ATCG occurs twice and their indices (i.e., (1,2,4,7) and (3,5,6,9)) do not overlap.\nDescribe a dynamic programming (recurrence) for this problem. Illustrate a bottom-\nup DP using the string ATACTCGAG.\n(d) Compute the Longest Palindrome Subsequence (LPS) in any sequence using\ndynamic programming. Given a string \"character,\" the LPS is \"carac.\" You should\nwrite down the recurrence and bottom-up computation.",
    "tables": [],
    "figures": []
  },
  "5a": {
    "text": "計算k個序列的最長公共子序列(LCS)的最佳子結構(recurrence)可描述為\n以下形式,當k=3時:\n\n假設我們有三個序列 S1、S2和S3,它們的長度分別為nl、n2和n3。\n我們定義 dp[i][j][k]為三個序列 S1[0..i-1]、S2[0..j-1] 和S3[0..k-1]的LCS 長度。\n則我們可以使用以下遞迴關係來填充dp數組:\n如果 S1[i-1] = S2[j-1] = S3[k-1],則dp[i][j][k] = dp[i-1][j-1][k-1] +1。\n否則,dp[i][j][k] = max(dp[i-1][j][k],dp[i][j-1][k], dp[i][j][k-1])。\n這個遞迴關係表示,在考慮第i、j和k個字符時,我們比較它們是否相等。如\n果相等,則LCS 長度增加1,並且我們考慮前一個字符時的LCS長度;如果不\n相等,則我們將LCS長度更新為前一個字符的LCS長度中的最大值。\n對於計算k個序列的長度為n的最長公共子序列,其時間複雜度為 O(n^3)。",
    "tables": [],
    "figures": []
  },
  "5b": {
    "text": "Mr. Smart 的方法存在一個錯誤,這是因為LCS12和剩餘序列之間的LCS 不一\n定是整體的LCS。考慮以下示例:序列A為\"ABCD\",序列B為\"ACBD\",序\n列C為\"ADBC\"。根據 Mr. Smart的方法,我們首先計算序列A和B的LCS,\n得到\"ABD\"。然後計算\"ABD\"和序列C的LCS,但是\"ABD\"和序列C的LCS\n是\"AD\",與序列A、B、C的LCS \"ABD\"不同。因此,Mr. Smart的方法不適\n用於找到k個序列的整體LCS。",
    "tables": [],
    "figures": []
  },
  "5c": {
    "text": "計算一個給定字符串中至少出現兩次的最長子序列,且要求它們的索引不能重\n疊的問題,可以通過動態規劃遞迴來解決:\n下面描述了動態規劃的遞迴關係,以及使用bottom-up 的方法對字符串\n\"ATACTCGAG\"進行動態規劃。\n遞迴關係:\n假設 dp[i][j]表示字符串中以索引i和j結尾的最長重複子序列的長度。\n我們可以使用以下遞迴關係來填充 dp數組:\n如果字符 s[i] 等於字符s[j]且i不等於j,則 dp[i][j] = dp[i-1][j-1] +1。\n否則,dp[i][j] = max(dp[i-1][j], dp[i][j-1])。\nbottom-up 的動態規劃:\n我們可以使用 bottom-up的方法來填充dp數組。首先初始化dp數組為零。然\n後遍歷字符串中的每對字符,根據上述遞迴關係來更新 dp數組。\n下面是對字符串 \"ATACTCGAG\" 的bottom-up 的動態規劃過程:\n初始時,dp 數組為:\n[TABLE]\n接著,遍歷字符串中的每對字符:\n\n```\n（續）\n字符 'A' 與字符'T'不相等,因此dp[1][0] = max(dp[0][0], dp[1][1]) = 0。\n字符 'T' 與字符'A'不相等,因此 dp[2][1] = max(dp[1][1], dp[2][2]) = 0。\n字符 'A' 與字符 'C' 不相等,因此 dp[3][2] = max(dp[2][2], dp[3][3]) = 0。\n依此類推,我們填充整個dp數組,最後找到dp數組中的最大值,即為最長重\n複子序列的長度。在這個例子中,最終dp[1][7] = dp[3][9] = 4 (ATCG 出現第二\n次),最長重複子序列的長度為4。",
    "tables": [
      "|   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n|---|---|---|---|---|---|---|---|---|---|\n|   | A | T | A | C | T | C | G | A | G |\n| 1 | A | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| 2 | T | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| 3 | A | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| 4 | C | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| 5 | T | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| 6 | C | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| 7 | G | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| 8 | A | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| 0 | G | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |"
    ],
    "figures": []
  },
  "5d": {
    "text": "要計算任何序列的最長回文子序列(Longest Palindrome Subsequence,LPS),\n可以使用動態規劃。\n以下是動態規劃的遞迴關係和bottom-up 的計算過程:\n遞迴關係:\n假設 dp[i][j]表示字符串中從索引i到索引」的子串的最長回文子序列的長度。\n我們可以使用以下遞迴關係來填充dp數組:\n如果字符 s[i] 等於字符s[j],則dp[i][j] = dp[i+1][j-1]+2。\n如果字符 s[i] 不等於字符s[j],則dp[i][j] = max(dp[i+1][j], dp[i][j-1])。\nbottom-up 的動態規劃:\n使用 bottom-up 的方法來填充 dp數組。首先初始化 dp數組為單個字符的長度\n為1,即dp[i][i] = 1。然後遍歷字符串中的每個子串的長度,根據上述遞迴關係\n來更新 dp 數組。\n下面是對字符串\"character\"的bottom-up的動態規劃過程:\n初始時,dp 數組為:(一個長度為1的字串本身就是迴文字串。)\n[TABLE]\n接著,遍歷字符串中的每個子串的長度:\n```\n```",
    "tables": [
      "|   |   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n|---|---|---|---|---|---|---|---|---|---|---|\n|   |   | c | h | a | r | a | c | t | e | r |\n| 1 | c | 1 |   |   |   |   |   |   |   |   |\n| 2 | h |   | 1 |   |   |   |   |   |   |   |\n| 3 | a |   |   | 1 |   |   |   |   |   |   |\n| 4 | r |   |   |   | 1 |   |   |   |   |   |\n| 5 | a |   |   |   |   | 1 |   |   |   |   |\n| 6 | c |   |   |   |   |   | 1 |   |   |   |\n| 7 | t |   |   |   |   |   |   | 1 |   |   |\n| 8 | e |   |   |   |   |   |   |   | 1 |   |\n| 0 | r |   |   |   |   |   |   |   |   | 1 |"
    ],
    "figures": []
  },
  "6": {
    "text": "Consider the knapsack problem of n items and W pack size. Suppose the pack/item\nsizes are very large and the item values are very small. Give a dynamic programming\nfor solving this problem. Illustrate your algorithm using the following example\n(W=500).\n[TABLE]\n在背包容量為W的情況下,解決n個物品的背包問題,可以使用動態規劃算法。\n令 dp[i][w] 表示在前i個物品中選擇使得重量不超過w的情況下的最大價值。\n則我們可以使用以下遞迴關係來計算 dp[i][w]:\n如果物品i的重量超過w,則dp[i][w] = dp[i-1][w],即不選擇物品i。\n否則,dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i]),即在選擇和不\n選擇物品i中取最大值。\n接下來我們可以使用這個遞迴關係填充一個二維數組dp。最後,答案即為\ndp[n][W]。\n使用例子中的數據(W=500,物品數n=4)填充dp:\ndp = [\n```\n```\n（續）\n[0,0,0, ..., 0],\n[0,0,0, ..., 0],\n[0,0,0, ..., 0],\n[0,0,0, ..., 0],\n[0,0,0, ..., 0]\n]\n現在填充 dp[4][500]:\n對於物品1,重量為100,價值為1。因為100 <= 500,所以dp[1][100] = 1,其\n它dp[1][w] = 0。\n對於物品2,重量為200,價值為2。因為200<=500,所以 dp[2][200] = 2,其\n它dp[2][w] = 0。\n對於物品3,重量為250,價值為4。因為250 <= 500,所以dp[3][250]=4,其\n它dp[3][w] = 0。\n對於物品4,重量為300,價值為5。因為300<=500,所以dp[4][300]=5,其\n它dp[4][w] = 0。\n現在我們使用上面的遞迴關係來計算 dp[4][500]。例如,對於dp[4][500],我們\n可以通過比較 dp[3][500]和dp[3][500-300] +5來得到最大值。\n這樣填充 dp 數組直到得到dp[4][500],我們就能得到最大價值。\n以下是範例:\n#include <stdio.h>\n#define max(a, b) ((a) > (b) ? (a) : (b))\n// 定義最大物品數量和最大背包容量\n#define MAX_ITEMS 100\n#define MAX_WEIGHT 1000\n// 物品的重量和價值\nint weight[MAX_ITEMS] = {100, 200, 250, 300};\nint value[MAX_ITEMS] = {1, 2, 4, 5};\n// 動態規劃函數\nint knapsack(int n, int W) {\nint dp[MAX_ITEMS + 1][MAX_WEIGHT + 1];\n```",
    "tables": [
      "| Item | Weight | Value |\n|------|--------|-------|\n| 1    | 100    | 1     |\n| 2    | 200    | 2     |\n| 3    | 250    | 4     |\n| 4    | 300    | 5     |"
    ],
    "figures": []
  },
  "7": {
    "text": "Consider the following six activities with (start time, finish time, and value): (2, 4, 3), (5, 5, 5), (3, 4, 2), (1, 4, 3), (1, 3, 1), (3, 5, 4). Illustrate a dynamic programming algorithm for computing the mutually exclusive subset of activities of maximum total values using the above example.\n使用動態規劃算法來計算具有最大總價值的互斥活動子集。\n以下是對於給定活動的動態規劃算法:\n首先,將活動按照結束時間進行排序,確保每次選擇的活動是不衝突的。\n然後,定義一個dp數組,其中 dp[i]表示在考慮前i個活動時的最大總價值。\n```\n（續）\n使用遞迴關係來填充這個數組。\n遞迴關係如下:\n如果第i個活動是第一個活動(即沒有其他活動與之相互排斥),則dp[i]等於\n第i個活動的價值。\n否則,對於每個結束時間早於第i個活動的活動j,我們可以計算 dp[i] =\nmax(dp[i], dp[j] + value[i])。\n最後,dp 數組中的最大值就是所求的相互排斥的活動子集的最大總價值。\n下面是範例:\n#include <stdio.h>\n// 定義活動結構\nstruct Activity {\nint start;\nint finish;\nint value;\n};\n// 按結束時間遞增排序\nvoid sortActivities(struct Activity activities[], int n) {\nfor (int i = 0; i < n - 1; i++) {\nfor (int j = 0; j < n - i - 1; j++) {\nif (activities[j].finish > activities[j+1].finish) {\n//交換活動\nstruct Activity temp = activities[j];\nactivities[j] = activities[j+1];\nactivities[j+1] = temp;\n}\n}\n}\n}\n// 動態規劃算法計算最大總價值\nint dynamicProgramming(struct Activity activities[], int n) {\n// 將活動按結束時間遞增排序\nsortActivities(activities, n);\n```\n（續）\n}\n\n// 初始化 dp 數組\nint dp[n];\nfor (int i = 0; i < n; i++) {\ndp[i] = activities[i].value;\n}\n// 填充 dp 數組\nfor (int i = 1; i < n; i++) {\nfor (int j = 0; j < i; j++) {\nif (activities[j].finish <= activities[i].start) {\ndp[i] = (dp[i] > dp[j] + activities[i].value) ? dp[i] : dp[j] + activities[i].value;\n}\n}\n}\n//找到最大總價值\nint maxTotalValue = 0;\nfor (int i = 0; i < n; i++) {\nif (dp[i] > maxTotalValue) {\nmaxTotal Value = dp[i];\n}\n}\nreturn maxTotal Value;\n}\n\nint main() {\n// 活動列表\nstruct Activity activities[] = {\n{2, 4, 3},\n{5, 5, 5},\n{3, 4, 2},\n{1, 4, 3},\n{1, 3, 1},\n{3, 5, 4}\n};\n\n```\n（續）\n}\n// 活動數量\nint n = sizeof(activities) / sizeof(activities[0]);\n// 計算最大總價值\nint maxTotalValue = dynamicProgramming(activities, n);\nprintf(\"最大總價值: %d\\n\", maxTotalValue);\nreturn 0;\n}\n這個動態規劃算法的時間複雜度取決於排序活動的時間複雜度和填充 dp數組的\n時間複雜度。\n排序活動:對活動按結束時間進行排序的時間複雜度 O(n log n) (快速排序),\n其中 n 是活動的數量。\n填充 dp 數組: 填充 dp 數組的時間複雜度為 O(n^2), 因為我們需要對每個活動 j\n找到結束時間早於當前活動的所有活動 j 進行比較。\n因此, 整個算法的時間複雜度為 O(n^2 + n log n)。 在最壞的情況下, 它可以簡化\n為 O(n^2), 因為排序的時間複雜度優於填充 dp 數組的時間複雜度。\n```",
    "tables": [],
    "figures": []
  }
}