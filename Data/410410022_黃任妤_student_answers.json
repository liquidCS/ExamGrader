{
  "1": {
    "text": "使用tail recursion:\nint Fibl int n, int a, int b) {\nif (n == 0)\nreturn a;\nreturn Fib (n-1, b, a+b);\n}",
    "tables": [],
    "figures": []
  },
  "2a": {
    "text": "T(n) = 2T(n/4)+T(n/3)+cn\n\n[FIGURE]\n=> cn\n=> 7/6 cn\n=> (7/6)^i cn\n（續）\nT(n) ≤ cn + (7/6)cn + (7/6)^2 cn + ...\n= ((7/6)^(log_(3/2) n) - 1) / (7/6 - 1) cn\n= 6(n^(log_(3/2) (7/6)) - 1) cn\n= 6c(n^(log_(3/2) (7/6)) - 1)\n= O(n^(log_(3/2) (7/6)))",
    "tables": [],
    "figures": [
      "A tree diagram. The root node is labeled T(n). It has three children nodes, labeled T(n/4), T(n/4), and T(n/3). Each of the T(n/4) node has two children. Each of the T(n/3) node has one children."
    ]
  },
  "2b": {
    "text": "Let k = lgn, n = 2^k\nT(n) = 2T(√n) + lgn\n=> T(2^k) = 2T(2^(k/2)) + k\nLet S(k) = T(2^k)\nS(k) = 2S(k/2) + k\nBy Master Theorem, log_2 2 = 1 => S(k) = O(k log k)\nT(2^k) = O(k log k) => T(n) = O(log n log log n)",
    "tables": [],
    "figures": []
  },
  "3": {
    "text": "使用數學歸納法\n當 h = 0, ∴ heap tree 是 binary tree\n∴ 最多有 [n/(2^(h+1))] = [n/(2^(0+1))] = [n/2] 個 nodes 在第0層成立.\n設 h = k, 最多有 [n/(2^(k+1))] 個 nodes 在第 k 層成立.\n則 h = k+1 時, 最多有 [( [n/(2^k)] ) / 2] = [n/(2^(k+1))] 個 nodes 在第k+1層, 與公式 [n/(2^(h+1))] 相符, 故得證.\n```\n```",
    "tables": [],
    "figures": []
  },
  "4": {
    "text": "若將小數都乘上一個很大的數,某些數字可能會變成一個過大的整數,導致超過 int\n能儲存的位數,即integer overflow。\n將小數字變大後,key的範圍及所需的儲存空間也會變大,可能導致stack overflow。\nCounting Sort的時間複雜度並非O(n)而是O(n+k),其中n由輸入數字的數量決定,k\n則由key的範圍決定。當key的範圍大到超過O(n)時,counting sort的複雜度由k決\n定,可能會比comparison based sorting 的O(nlogn)來得更慢。",
    "tables": [],
    "figures": []
  },
  "5a": {
    "text": "Let the 3 sequences be A, B, and C.\nLCS (i, j, k) denotes the LCS of A[1.2,..., i], B[1,2,...,j] and C[1,2,..., k].\nLCS (i, j, k) =\n{\n0, if i=0 or j=0 or k=0\nLCS (i-1, j-1, k-1)+1, if A[i] = B[j] = C[k]\nmax { LCS (i-1, j,k), LCS (i, j-1, k), LCS(i, j, k-1)}, otherwise\nTime Complexity: O(n^3)",
    "tables": [],
    "figures": []
  },
  "5b": {
    "text": "先計算字串A,B的LCS時,可能找到一個比A,B,C的LCS更長的\n共同子序列,此時再拿這個子序列和C比時,就可能錯過最佳解。\nex: A = kirari live\nB = livekirari\nC = live\nLCS (A,B) = kirari\nLCS (\"kirari\", C) = i\n但LCS(A,B,C) = live,此方法不可行",
    "tables": [],
    "figures": []
  },
  "5c": {
    "text": "① Recurrence\nLet the given sequence be S.\ndp (i,j) = \n{\n0, if i=0 or j = 0\ndp(i-1, j-1)+1, if s[i] = s[j] and i ≠ j\nmax { dp (i-1,j), dp(i,j-1)}, otherwise\n\n② Bottom-up DP\n[TABLE]\n=> Print in reverse order: ATCG\n```",
    "tables": [
      "|   | j   | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  |\n|---|-----|----|----|----|----|----|----|----|----|----|----|\n| i | S_j | A  | T  | A  | C  | T  | C  | G  | A  | G  |\n| 0 | S_i | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  |\n| 1 | A   | 0  | 0  | 0  | 1  | 1  | 1  | 1  | 1  | 1  | 1  |\n| 2 | T   | 0  | 0  | 0  | 1  | 1  | 2  | 2  | 2  | 2  | 2  |\n| 3 | A   | 0  | 1  | 1  | 1  | 1  | 2  | 2  | 2  | 3  | 3  |\n| 4 | C   | 0  | 1  | 1  | 1  | 1  | 2  | 3  | 3  | 3  | 3  |\n| 5 | T   | 0  | 1  | 2  | 2  | 2  | 2  | 3  | 3  | 3  | 3  |\n| 6 | C   | 0  | 1  | 2  | 2  | 3  | 3  | 3  | 3  | 3  | 3  |\n| 7 | G   | 0  | 1  | 2  | 2  | 3  | 3  | 3  | 3  | 3  | 4  |\n| 8 | A   | 0  | 1  | 2  | 3  | 3  | 3  | 3  | 3  | 4  | 4  |\n| 9 | G   | 0  | 1  | 2  | 3  | 3  | 3  | 3  | 4  | 4  | 4  |"
    ],
    "figures": []
  },
  "5d": {
    "text": "(d) LPS即原序列和其反轉序列的LCS\n原序列S=character\n反轉序列Ś=retcarahc\n① Recurrence 計算序列S和S的LCS\ndp(i,j) = { 0, if i=0 or j=0\ndp(i-1,j-1)+1, if s[i] = s[j]\nmax { dp(i-1,j), dp(i,j-1)}, otherwise *\n\n② Bottom-up\n[TABLE]\n⇒ carac *",
    "tables": [
      "| i | j | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n|---|---|---|---|---|---|---|---|---|---|---|---|\n|   | S_j | c | h | a | r | a | c | t | e | r |   |\n| 0 | S_i | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| 1 | r | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 |\n| 2 | e | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 2 | 2 |\n| 3 | t | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 2 | 2 | 2 |\n| 4 | c | 0 | 1 | 1 | 1 | 1 | 2 | 2 | 2 | 2 | 2 |\n| 5 | a | 0 | 1 | 1 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |\n| 6 | r | 0 | 1 | 1 | 2 | 3 | 3 | 3 | 3 | 3 | 3 |\n| 7 | a | 0 | 1 | 1 | 2 | 3 | 4 | 4 | 4 | 4 | 4 |\n| 8 | c | 0 | 1 | 2 | 2 | 3 | 4 | 4 | 4 | 4 | 4 |\n| 9 | t | 0 | 1 | 2 | 2 | 3 | 4 | 5 | 5 | 5 | 5 |"
    ],
    "figures": []
  },
  "6": {
    "text": "6. ① Let V_i = value of the ith item.\nW_i = weight of the ith item.\ndp(i,j) = the minimum weight to achieve value j using the first i items.\n(1 ≤ i ≤ n, 0 ≤ j ≤ V, where V represents the sum of values.)\ndp(i,j)= { 0, if i=0 or j=0\nmax { dp[i-1,j), dp(i-1, j-V_i) + W_i}, otherwise *\n\n②置表找出小於背包重量W=500的最大價值.\n[TABLE]\n⇒ value = 7 *",
    "tables": [
      "| i | j | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n| 1 |   | 0 | 100 | \\ | \\ | \\ | \\ | \\ | \\ | \\ | \\ | \\ | \\ | \\ |\n| 2 |   | 0 | 100 | 200 | 300 | \\ | \\ | \\ | \\ | \\ | \\ | \\ | \\ | \\ |\n| 3 |   | 0 | 100 | 200 | 300 | 250 | 350 | 450 | 550 | \\ | \\ | \\ | \\ | \\ |\n| 4 |   | 0 | 100 | 200 | 300 | 450 | 300 | 400 | 500 | 600 | 550 | 650 | 750 | 810 |"
    ],
    "figures": []
  },
  "7": {
    "text": "Sort by the finish time.\nLet H(i) = max{l = {1, 2, ..., i-1} | f_l ≤ s_i}\nLet A(i) = max{A(i-1), A(H(i)) + v_i} (A(i) = max value for activity 1 to i)\n[TABLE]\n⇒ maximum value = 10",
    "tables": [
      "| activity | 1 | 2 | 3 | 4 | 5 | 6 |\n|----------|---|---|---|---|---|---|\n| start    | 1 | 1 | 2 | 3 | 3 | 5 |\n| finish   | 3 | 4 | 4 | 4 | 5 | 5 |\n| value    | 1 | 3 | 3 | 2 | 4 | 5 |\n| H(i)     | 0 | 0 | 0 | 1 | 1 | 5 |\n| A(i)     | 1 | 3 | 3 | 4 | 5 | 10 |"
    ],
    "figures": []
  }
}