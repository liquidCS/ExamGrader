{
  "1": {
    "text": "可以用tail recursion,因為把recursion擺在函式的最後一步,\n讓 call stack 不會被呼叫時創建的新frame塞滿,從而避免stack\noverflow.\ntail recursion:\nint fib (int n, int a, int b) {\nif (n==0)\nreturn a;\nif (n == 1)\nreturn b;\nreturn fib (n-1, b, a+b);\n}",
    "tables": [],
    "figures": []
  },
  "2a": {
    "text": "T(n)=2T(n/4)+T(2n/3)+cn\n[FIGURE]\n=> T(n) ≤ Σ_{i=0}^∞ ((7/6)^i)cn\n=> T(n) ≤ 1/(1-(7/6))cn\n=>T(n) = O(n)",
    "tables": [],
    "figures": [
      "A recursion tree is drawn. The root node is T(n). It branches into three children: T(n/4), T(n/4), and T(2n/3). The next level down has each of these nodes branching again, and the sums of the nodes in each level are marked as (7/6)n and (49/36)n"
    ]
  },
  "2b": {
    "text": "T(n) = 2T(√n) + log n\nset k = log n, n=2^k.\n=>T(2^k) = 2T(2^(k/2)) + k\nset S(k) = T(2^k)\n=> S(k) = 2S(k/2) + k\n=> S(k) ≤ 2S(k/2) + ck use Master Theorem => S(k) = O(k log k)\n=> T(n) = O(log n * log log n)",
    "tables": [],
    "figures": []
  },
  "3": {
    "text": "heap tree 是二元樹\n∴ leaf nodes 最多有 n/2 個\nh=0, ⌈n/(2^(0+1))⌉ = n/2\nh=k, ⌈n/(2^(k+1))⌉\nh= k+1, ⌈n/(2^(k+1))/2⌉ = ⌈n/(2^(k+1)×2)⌉=> ⌈n/(2^(k+1))⌉與公式相符 => 由數學歸納法證明此題論述為正確\n\nHere are the answers extracted from the provided text:",
    "tables": [],
    "figures": []
  },
  "4": {
    "text": "全部乘以大數, 很有可能overflow",
    "tables": [],
    "figures": []
  },
  "5a": {
    "text": "LCS(i,j,k) = { 0 if k=0\nLCS(i-1,j-1, k-1) + 1 if c_i == c_j == c_k else\nmax(LCS(i-1,j,k), LCS(i,j-1,k), LCS(i,j,k-1))\n\nTime Complexity: O(n × n × ... n) => O(n^k)",
    "tables": [],
    "figures": []
  },
  "5b": {
    "text": "set i = \"HELWOR\"\nj = \"HELOW\"\nk = \"HEO\"\nLCS(i,j,k) = \"HEO\" => 字串 i,j 的最佳解 不一定是 i,j,k 的最佳解\nLCS(LCS(i,j),k) = \"HE\"",
    "tables": [],
    "figures": []
  }
}