
題號 1:
題目內容：Suppose you are asked to implement the n-th Fibanacci number using recursion only (i.e., no loop implementation)? How to avoid stack overflow for large n?

標準答案：使用tail recursion:
int Fibl int n, int a, int b) {
if (n == 0)
return a;
return Fib (n-1, b, a+b);
}

學生答案：使用tail recubion
int fibc int n, int a, int b) {
if(n==0){
return a;
}
return fib(n-1, b, a+b);
}

得分：10.0/10
理由：學生答案完全使用了尾遞迴的方式，其結構與標準答案一致，只是變數名稱略有不同，但邏輯完全相同，符合題目要求。

==================================================

題號 2a:
題目內容：T(n) = 2T(n/4) + T(2n/3) + cn, where c is a constant.

標準答案：T(n) = 2T(n/4) + T(2n/3) + cn

<FIGURE>
A tree diagram with T(n) at the root. T(n) has three children: T(n/4), T(n/4), and T(2n/3). Each of T(n/4) and T(2n/3) have two children. The diagram illustrates the expansion of the recurrence.
</FIGURE>

cn
7/6 cn
(7/6)^2 cn
T(n) ≤ cn + (7/6)cn + (7/6)^2cn + ...
= ((7/6)^(log_(3/2)n) - 1) / (7/6 - 1) cn
= 6(n^(log_(3/2)(7/6)) - 1) cn
= 6c(n^(log_(3/2)(7/4)) - 1)
= O(n^(log_(3/2)(7/4)))

學生答案：T(n) => T(n) ≤ (1 + 7/6 + (7/6)^2 + ... ) cn = ((1-(7/6)^n)/(1-7/6))cn = ∞cn = O(n)

得分：0.0/10
理由：學生答案最終得到的漸進上界 O(n) 與標準答案 O(n^(log_(3/2)(7/4))) 完全不同，其論證過程中將等比級數求和錯誤地視為無窮和，未能正確反映遞迴樹的複雜度。

==================================================

題號 2b:
題目內容：T(n) = 2T(\sqrt{n}) + lgn (hint: you may replace n with other form)

標準答案：Let k = lgn, n = 2^k
T(n) = 2T(√n) + lgn
⇒ T(2^k) = 2T(2^(k/2)) + k
Let S(k) = T(2^k)
S(k) = 2S(k/2) + k
By Master Theorem, log_2(2) = 1 ⇒ S(k) = O(klogk)
T(2^k) = O(klogk) ⇒ T(n) = O(logn loglogn)

學生答案：n = 2^(2k) T(n) = 2T(√n) + logn
T(n) = T(2^(2k)) = 2T(2^(2^(k-1))) + 2^k
=> 2 × (2 × T(2^(2^(k-2))) + 2^(k+1)) + 2^k
=> 2^2 × T(2^(2^(k-2))) + 2^k + 2^k
; k
2^k × T(2) + k × 2^k => O(k × 2^k) => O(log n log log n)

得分：8.0/10
理由：學生答案最終得出 O(log n log log n) 的結果，與標準答案一致，且重點上大部分相符。不過，在替換 n 的形式和展開遞迴關係的過程中存在一些不嚴謹或錯誤的地方，因此沒有給滿分。

==================================================

題號 3:
題目內容：Prove that an n-element heap has at most [n/2^{h+1}] nodes at height h.

標準答案：使用數學歸納法
當h=0, ∴heap tree 是 binary tree
∴最多有 ⌈n/(2^(h+1))⌉ = ⌈n/(2^(0+1))⌉ = ⌈n/2⌉ 成立。
設h=k, 最多有 ⌈n/(2^(k+1))⌉ 個 nodes 在第k層成立。
則h=k+1時，最多有 ⌈(n/2^(k+1))/2⌉ = ⌈n/(2^(k+1+1))⌉ 個 nodes 在第k+1層，與公式 ⌈n/(2^(h+1))⌉ 相符, 故得證
```
```

學生答案：heap 要是 complete binary tree, 最多會有 2/n 個 node 在底部
公式 「n/(2^(k+1))」代入口符合最多有 n/2 nodes
則h=k、有 「n/(2^(k+1))」個 node 在高為k時,
h = k+1 有「n/2^(k+1)」
∴ 得證最多有「n/(2^(k+1))」nodes 在高為h時

得分：4.0/10
理由：學生答案僅簡略地提出公式替換，未完整展示數學歸納的結構（例如基礎案例與歸納假設／歸納步驟），論證過程缺乏細節，僅僅重複公式而未充分說明，僅觸及部分重點。

==================================================

題號 4:
題目內容：Mr. Stupid claims we can sort n real numbers in linear time by multiplying a large integer to each real number such that all of them become integers. Then, the counting sort can be used to sort these integers in linear time. What is the problem of this method?

標準答案：若將小數都乘上一個很大的數,某些數字可能會變成一個過大的整數,導致超過 int
能儲存的位數,即integer overflow。
將小數字變大後,key的範圍及所需的儲存空間也會變大,可能導致stack overflow。
Counting Sort的時間複雜度並非O(n)而是O(n+k),其中n由輸入數字的數量決定,k
則由key的範圍決定。當key的範圍大到超過O(n)時,counting sort的複雜度由k決
定,可能會比comparison based sorting 的O(nlogn)來得更慢。

學生答案：會 overflow, 因為每使小數變很大
是 Counting sort 的複雜度是 O(n+k), k太大也會有機會提
linear time.

得分：5.0/5
理由：學生答案指出了大數乘法可能導致 overflow 以及 Counting Sort 的複雜度是 O(n+k) 且 k 太大會使時間複雜度失去線性，這與標準答案論點完全一致。

==================================================

題號 5a:
題目內容：Write the optimal substructure (recurrence) of computing LCS of k sequences, where k = 3
(5%). What is the time complexity of computing LCS for k sequences of length n (5%).

標準答案：Let the 3 sequences be A, B, and C.
LCS (i, j, k) denotes the LCS of A[1.2,..., i], B[1,2,j] and C[1,2,…, k].
LCS (i, j, k) =
{
0, if i=0 or j=0 or k=0
LCS (i-1, j-1, k-1)+1, if A[i] = B[j] = C[k]
max { LCS (i-1, j,k), LCS (i, j-1, k), LCS(i, j, k-1)}, otherwise
}
Time Complexity: O(n^3)

學生答案：LCS(i, j, k) = { 0, if i=0 or j=0 or k=0; LCS(i-1, j-1, k-1) + 1 if x_i = y_j = z_k; max{LCS(i-1, j, k), LCS(i, j-1, k), LCS(i, j, k+1)} otherwise.
O(n k)
```
```
（續）
(b) 如果取 LCS(LCS(x,y),Z) 因LCS有多組解,不能保證
LCS(x,y)是對子的最佳解
如: x=badly, z=badminton
y= bad school
LCS(x,y) = badl
Lcs (LCS(X,Y), K) = bad

得分：0.0/10
理由：學生答案中的遞迴關係式在非匹配情況下寫錯了（用了 LCS(i, j, k+1) 而非正確的 LCS(i, j, k–1)），而且時間複雜度也錯誤，應為 O(n³) 而非 O(nk)。

==================================================

題號 5b:
題目內容：Mr. Smart claimed that the LCS of three sequences can be obtained by first computing LCSs of any two sequences (say LCS12), and then compute LCS of LCS12 and the remaining sequence. What's the bug of this method? Give an example.

標準答案：先計算字串A,B的LCS時,可能找到一個比A,B,C的LCS更長的
共同子序列,此時再拿這個子序列和C比時,就可能錯過最佳解。
ex: A = kirari live
B = livekirari
C = live
LCS (A,B) = kirari
LCS ("kirari", C) = i
但LCS(A,B,C) = live,此方法不可行

學生答案：無學生答案

得分：0.0/5
理由：學生未提交任何答案，未涉及到標準答案中提到的計算順序導致錯過最佳解的觀點與例子。

==================================================

題號 5c:
題目內容：Given a string, find the longest subsequence occurring at least twice in the string, requiring their indices must not overlap. e.g., Given ATACTCGAG, the answer is 4 since ATCG occurs twice and their indices (i.e., (1,2,4,7) and (3,5,6,9)) do not overlap. Describe a dynamic programming (recurrence) for this problem. Illustrate a bottom-up DP using the string ATACTCGAG.

標準答案：① Recurrence
Let the given sequence be S.
dp (i,j) = 
{
0, if i=0 or j = 0
dp(i-1, j-1)+1, if S[i] = S[j] and i ≠ j
max { dp (i-1,j), dp(i,j-1)}, otherwise
}

② Bottom-up DP
[TABLE]
=> Print in reverse order: ATCG
```
標準答案表格：
| i\j | 0  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|-----|----|---|---|---|---|---|---|---|---|---|
| i   | S_j| A | T | A | C | T | C | G | A | G |
| 0   | S_i| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1   | A  | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 2   | T  | 0 | 0 | 0 | 1 | 1 | 2 | 2 | 2 | 2 |
| 3   | A  | 0 | 1 | 1 | 1 | 1 | 2 | 2 | 2 | 3 |
| 4   | C  | 0 | 1 | 1 | 1 | 2 | 2 | 3 | 3 | 3 |
| 5   | T  | 0 | 1 | 2 | 2 | 2 | 2 | 3 | 3 | 3 |
| 6   | C  | 0 | 1 | 2 | 2 | 3 | 3 | 3 | 3 | 3 |
| 7   | G  | 0 | 1 | 2 | 2 | 3 | 3 | 3 | 3 | 4 |
| 8   | A  | 0 | 1 | 2 | 3 | 3 | 3 | 3 | 3 | 4 |
| 9   | G  | 0 | 1 | 2 | 3 | 3 | 3 | 3 | 4 | 4 |

學生答案：recurrence: LRS(i,j) = {0, if i=0 or j=0
1+ LRS(i-1, j-1), if char_i = char_j and i ≠ j
max(LRS(i, j-1), LRS(i-1, j)), otherwise

[TABLE]
Ans: 4
學生答案表格：
| i\j | A | T | A | C | T | C | G | A | G |
|-----|---|---|---|---|---|---|---|---|---|
| 0   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| A   | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| T   | 0 | 0 | 1 | 1 | 2 | 2 | 2 | 2 | 2 |
| A   | 0 | 0 | 1 | 1 | 2 | 3 | 3 | 3 | 3 |
| C   | 0 | 0 | 1 | 1 | 2 | 3 | 3 | 3 | 3 |
| T   | 0 | 0 | 1 | 1 | 2 | 3 | 3 | 3 | 3 |
| C   | 0 | 0 | 1 | 2 | 2 | 3 | 3 | 3 | 3 |
| G   | 0 | 0 | 1 | 2 | 2 | 3 | 3 | 3 | 4 |
| A   | 0 | 1 | 1 | 2 | 2 | 3 | 3 | 3 | 4 |
| G   | 0 | 1 | 1 | 2 | 2 | 3 | 4 | 4 | 4 |

得分：10.0/10
理由：學生答案正確給出了與標準答案一致的遞推關係式和動態規劃表格，最終結果也正確得到4分。無論是遞推式的表述還是表格的填寫，均完全捕捉到題目關鍵要求。

==================================================

題號 5d:
題目內容：Compute the Longest Palindrome Subsequence (LPS) in any sequence using dynamic programming. Given a string "character," the LPS is "carac." You should write down the recurrence and bottom-up computation.

標準答案：(d) LPS即原序列和其反轉序列的LCS
原序列S=character
反轉序列Ś=retcarahc
① Recurrence 計算序列S和S'的LCS
dp(i,j) = { 0, if i=0 or j=0
dp(i-1, j-1) + 1, if S[i] = S[j]
max{dp(i-1, j), dp(i, j-1)}, otherwise
② Bottom-up

[TABLE]

⇒ carac
標準答案表格：
| i  | Sj          | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|----|-------------|---|---|---|---|---|---|---|---|---|---|
| 0  | Si          | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1  | r           | 0 | 0 | 0 | 0 | 0 | 1 | 1 | / | / | / |
| 2  | e           | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 2 |
| 3  | t           | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 2 | 2 |
| 4  | c           | 0 | 1 | 1 | 1 | 1 | 1 | 2 | 2 | 2 | 2 |
| 5  | a           | 0 | 1 | 1 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
| 6  | r           | 0 | 1 | 1 | 2 | 3 | 3 | 3 | 3 | 3 | 3 |
| 7  | a           | 0 | 1 | 1 | 2 | 3 | 4 | 4 | 4 | 4 | 4 |
| 8  | h           | 0 | 1 | 2 | 2 | 3 | 4 | 4 | 4 | 4 | 4 |
| 9  | c           | 0 | 1 | 2 | 2 | 3 | 4 | 5 | 5 | 5 | 5 |

學生答案：recurrence: LPS(i, j) = {0, if i=0 or j=0
LPS(i-1, j-1) + 1, if x[i] == y[j]
max{LPS(i-1, j, K), LPS(i, j-1, K)}, otherwise

追蹤:
[TABLE]

Ans: carac
```
```
學生答案表格：
| i\j | null | c | h | a | r | a | c | t | e | r |
|-----|------|---|---|---|---|---|---|---|---|---|
| null | 0    | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| r    | 0    | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 2 |
| e    | 0    | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 2 | 2 |
| t    | 0    | 0 | 0 | 0 | 1 | 1 | 1 | 2 | 2 | 2 |
| c    | 0    | 1 | 1 | 1 | 2 | 2 | 2 | 2 | 2 | 2 |
| a    | 0    | 1 | 1 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
| r    | 0    | 1 | 1 | 2 | 3 | 3 | 3 | 3 | 3 | 4 |
| a    | 0    | 1 | 1 | 3 | 3 | 4 | 4 | 4 | 4 | 4 |
| c    | 0    | 1 | 2 | 3 | 4 | 4 | 5 | 4 | 5 | 4 | 5 |

得分：10.0/10
理由：學生答案正確寫出了動態規劃的遞迴關係式（僅使用了略異的符號表示）及底-up的表格，其計算結果與標準答案相同（LPS為 "carac"），符合評分規則。

==================================================

題號 6:
題目內容：Consider the knapsack problem of n items and W pack size. Suppose the pack/item sizes are very large and the item values are very small. Give a dynamic programming for solving this problem. Illustrate your algorithm using the following example (W=500).
[TABLE]
題目表格：
| Item | Weight | Value |
|------|--------|-------|
| 1    | 100    | 1     |
| 2    | 200    | 2     |
| 3    | 250    | 4     |
| 4    | 300    | 5     |

標準答案：6. ① Let v_i = value of the ith item.
w_i = weight of the ith item.
dp(i, j) = the minimum weight to achieve value j using the first i items. (1 ≤ i ≤ n, 0 ≤ j ≤ V, where V represents the sum of values.)
dp(i, j) = { 0, if i = 0 or j = 0
max {dp(i-1, j), dp(i-1, j - v_i) + w_i}, otherwise
②置表找出小於背包重量W=500的最大價值.

[TABLE]

⇒ value = 7
標準答案表格：
| i | j | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  |
|---|---|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| 1 |   | 0   | 100 | /   | /   | /   | /   | /   | /   | /   | /   | /   | /   | /   |
| 2 |   | 0   | 100 | 200 | 300 | /   | /   | /   | /   | /   | /   | /   | /   | /   |
| 3 |   | 0   | 100 | 200 | 300 | 250 | 350 | 450 | 550 | /   | /   | /   | /   | /   |
| 4 |   | 0   | 100 | 200 | 300 | 250 | 300 | 400 | 500 | 600 | 550 | 650 | 750 | 850 |

學生答案：recurrence
dp (V, i) = { 0, j = 0 or i = 0
max(dp(i-1, j), dp(i-1, j-v_i) + w_i), otherwise
令dp為組合出價值為j的最小重量。
[TABLE]
學生答案表格：
| item | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 總value |
|------|---|---|---|---|---|---|---|---|---|---|----|----|----|---------|
| 1    | 0 | 100 | × | × | × | × | × | × | × | × | ×  | ×  | ×  |         |
| 2    | 0 | 100 | 200 | 300 | × | × | × | × | × | × | ×  | ×  | ×  |         |
| 3    | 0 | 100 | 200 | 300 | 250 | 350 | 450 | 550 |    |    |    |    |    |         |
| 4    | 0 | 100 | 200 | 300 | 250 | 300 | 400 | 500 |    |    |    |    |    |         |

得分：10.0/10
理由：學生答案正確定義了dp狀態、遞迴關係（即利用dp(i, j)表示達到價值j的最小重量）並給出了與標準答案基本一致的動態規劃表格，最終得到和標準答案一樣的結果。

==================================================

題號 7:
題目內容：Consider the following six activities with (start time, finish time, and value): (2, 4, 3), (5, 5, 5), (3, 4, 2), (1, 4, 3), (1, 3, 1), (3, 5, 4). Illustrate a dynamic programming algorithm for computing the mutually-exclusive subset of activities of maximum total values using the above example.

標準答案：Sort by the finish time.
Let H(i) = max{l={1, 2, ..., i-1} | f_l ≤ s_i}
Let A(i) = max{A(i-1), A(H(i)) + v_i} (A(i) = max value for activity 1 to i)
[TABLE]
⇒ maximum value = 10
標準答案表格：
| activity | 1 | 2 | 3 | 4 | 5 | 6 |
|----------|---|---|---|---|---|---|
| start    | 1 | 1 | 2 | 3 | 3 | 5 |
| finish   | 3 | 4 | 4 | 4 | 5 | 5 |
| value    | 1 | 3 | 3 | 2 | 4 | 5 |
| H(i)     | 0 | 0 | 0 | 1 | 1 | 5 |
| A(i)     | 1 | 3 | 3 | 4 | 5 | 10 |

學生答案：Sort by finish time
H(i) = max {l = {1, 2, ..., i-1} | f_l ≤ s_i}
A(i) = { 0 , if i=0
max{A(i-1), A(H(i)) + V_i}, otherwise
[TABLE]
Ans. 7
<FIGURE>The figure contains a series of horizontal lines representing activities 1 through 6. The x-axis represents time, from left to right. Each line starts at the activity's start time and ends at its finish time. The value 'v' associated with activities 3, 4, 5, and 6 are shown adjacent to the activity line. The values are: v=1 (near act 1), v=3(near act 2), v=3 (near act 3), v=2 (near act 4), v=4 (near act 5), v=5 (near act 6).
</FIGURE>
{ activity: 1, 5, 6
value : 10
```
學生答案表格：
| activity | 1 | 2 | 3 | 4 | 5 | 6 |
|----------|---|---|---|---|---|---|
| start    | 1 | 1 | 2 | 3 | 3 | 5 |
| finish   | 3 | 4 | 4 | 4 | 5 | 5 |
| value    | 1 | 3 | 3 | 2 | 4 | 5 |
| H(i)     | 0 | 0 | 0 | 1 | 1 | 5 |
| A(i)     | 1 | 3 | 3 | 3 | 5 | 10 |

得分：8.0/10
理由：學生答案正確地描述了排序、求 H(i) 的方法及遞迴關係 A(i)=max{A(i–1), A(H(i))+Vᵢ}。不過其動態規劃表中在 A(4) 的計算有誤（應為4，但表中記為3），且題目答案處標示 “Ans. 7” 與後續圖中「activity: 1, 5, 6，value: 10」不一致。儘管最終活動選取和最大值應為10，這些小錯誤導致答案略有不一致，因此給予 8 分。

==================================================

總分：65.0
